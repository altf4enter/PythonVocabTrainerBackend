# -*- coding: utf-8 -*-
"""parse_help_string.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xIquJcFyPafv4Eko3IyUKYBjV8QSHvqP
"""

#TODO: beschreibungen von kwargs wird nicht f√ºr **kwargs erkannt

import re
from nltk.tokenize import word_tokenize, sent_tokenize
import nltk
from anytree import Node, RenderTree, LevelOrderIter
import json
from functionDescriptionNode import FunctionDescriptionNode
from classNode import ClassNode
import get_parse_tree
import sys
import io

def parse_class_text(s,classname,prnt=False):
  #constructors
  #functions
  tree = get_parse_tree.get_parsed_tree(s,classname=classname,prnt=prnt)
  classnode = tree.children[1]
  #print(classnode.text)

  if type(classnode) == ClassNode:
    return classnode.toJSON()
  else:
    raise Exception("is not classnode, is",type(classnode))

#param funcname: has to be the name of the function, without dot notation of
#package
def parse_function_text(s,funcname,prnt=False):
  tree = get_parse_tree.get_parsed_tree(s,prnt=prnt)
  funcnode =  [node for node in LevelOrderIter(tree) if type(node) == FunctionDescriptionNode and node.func_name == funcname][0]#tree.children[1]

  if type(funcnode) == FunctionDescriptionNode:
    #print(json.dumps(funcnode.toJSON(), indent=1))
    return funcnode.toJSON()
  else:
    raise Exception("is not funcnode, is",type(funcnode))

#TODO anderes format wenn als string als als "objekt"

def parse_text(text,prnt=False):
    if re.match("^No Python documentation found",text):
        raise Exception("No Python documentation found.")
    words = text.split(" ")
    if words[2]== "function":
        return parse_function_text(text,words[3],prnt)
    if words[2] == "class":
        return parse_class_text(text,words[3],prnt)
    else:
        raise Exception("Documentation of not supported module element type.")
        

#text = ""
#f = open("C:/Users/helen/Desktop/App/raw_help_texts/classes/anytree.Node.txt",'r',encoding='utf-8')
#text = str(f.read())
#f.close()      
#parsed = parse_text(text,prnt=True)
#print(json.dumps(parsed, indent=4, sort_keys=True))


def get_help_str(obj):
    old_stdout = sys.stdout
    new_stdout = io.StringIO()
    sys.stdout = new_stdout
    help(obj)
    output = new_stdout.getvalue()
    sys.stdout = old_stdout
    return output